<HTML><HEAD><SCRIPT language="JavaScript" src="../resources/script.js" type="text/javascript"></SCRIPT><TITLE>XMLString Class Reference</TITLE><link href="XercesApi.css" rel="stylesheet" type="text/css"></HEAD><BODY alink="#ff0000" bgcolor="#ffffff" leftmargin="4" link="#0000ff" marginheight="4" marginwidth="4" text="#000000" topmargin="4" vlink="#0000aa"><TABLE border="0" cellpadding="0" cellspacing="0" width="620"><TR><TD align="left" height="60" rowspan="3" valign="top" width="135"><IMG border="0" height="60" hspace="0" src="../resources/logo.gif" vspace="0" width="135"></TD><TD align="left" colspan="4" height="5" valign="top" width="456"><IMG border="0" height="5" hspace="0" src="../resources/line.gif" vspace="0" width="456"></TD><TD align="left" height="60" rowspan="3" valign="top" width="29"><IMG border="0" height="60" hspace="0" src="../resources/right.gif" vspace="0" width="29"></TD></TR><TR><TD align="left" bgcolor="#0086b2" colspan="4" height="35" valign="top" width="456"><IMG alt="" border="0" height="35" hspace="0" src="../graphics/api-header.jpg" vspace="0" width="456"></TD></TR><TR><TD align="left" height="20" valign="top" width="168"><IMG border="0" height="20" hspace="0" src="../resources/bottom.gif" vspace="0" width="168"></TD><TD align="left" height="20" valign="top" width="96"><A href="http://xml.apache.org/" onMouseOut="rolloverOff('xml');" onMouseOver="rolloverOn('xml');" target="new"><IMG alt="http://xml.apache.org/" border="0" height="20" hspace="0" name="xml" onLoad="rolloverLoad('xml','../resources/button-xml-hi.gif','../resources/button-xml-lo.gif');" src="../resources/button-xml-lo.gif" vspace="0" width="96"></A></TD><TD align="left" height="20" valign="top" width="96"><A href="http://www.apache.org/" onMouseOut="rolloverOff('asf');" onMouseOver="rolloverOn('asf');" target="new"><IMG alt="http://www.apache.org/" border="0" height="20" hspace="0" name="asf" onLoad="rolloverLoad('asf','../resources/button-asf-hi.gif','../resources/button-asf-lo.gif');" src="../resources/button-asf-lo.gif" vspace="0" width="96"></A></TD><TD align="left" height="20" valign="top" width="96"><A href="http://www.w3.org/" onMouseOut="rolloverOff('w3c');" onMouseOver="rolloverOn('w3c');" target="new"><IMG alt="http://www.w3.org/" border="0" height="20" hspace="0" name="w3c" onLoad="rolloverLoad('w3c','../resources/button-w3c-hi.gif','../resources/button-w3c-lo.gif');" src="../resources/button-w3c-lo.gif" vspace="0" width="96"></A></TD></TR></TABLE><TABLE border="0" cellpadding="0" cellspacing="0" width="620"><TR><TD align="left" valign="top" width="120"><IMG border="0" height="14" hspace="0" src="../resources/join.gif" vspace="0" width="120"><BR>
  <A href="../../index.html" onMouseOut="rolloverOff('side-ext-2');" onMouseOver="rolloverOn('side-ext-2');"><IMG alt="Home" border="0" height="12" hspace="0" name="side-ext-2" onLoad="rolloverLoad('side-ext-2','../graphics/ext-2-label-2.jpg','../graphics/ext-2-label-3.jpg');" src="../graphics/ext-2-label-3.jpg" vspace="0" width="120"></A><BR>

  <IMG border="0" height="6" hspace="0" src="../resources/separator.gif" vspace="0" width="120"><BR>

  <A href="../index.html" onMouseOut="rolloverOff('side-index');" onMouseOver="rolloverOn('side-index');"><IMG alt="Readme" border="0" height="12" hspace="0" name="side-index" onLoad="rolloverLoad('side-index','../graphics/index-label-2.jpg','../graphics/index-label-3.jpg');" src="../graphics/index-label-3.jpg" vspace="0" width="120"></A><BR>
  <A href="http://xml.apache.org/dist/xerces-c/" onMouseOut="rolloverOff('side-ext-8');" onMouseOver="rolloverOn('side-ext-8');"><IMG alt="Download" border="0" height="12" hspace="0" name="side-ext-8" onLoad="rolloverLoad('side-ext-8','../graphics/ext-8-label-2.jpg','../graphics/ext-8-label-3.jpg');" src="../graphics/ext-8-label-3.jpg" vspace="0" width="120"></A><BR>
  <A href="../install.html" onMouseOut="rolloverOff('side-install');" onMouseOver="rolloverOn('side-install');"><IMG alt="Installation" border="0" height="12" hspace="0" name="side-install" onLoad="rolloverLoad('side-install','../graphics/install-label-2.jpg','../graphics/install-label-3.jpg');" src="../graphics/install-label-3.jpg" vspace="0" width="120"></A><BR>
  <A href="../build.html" onMouseOut="rolloverOff('side-build');" onMouseOver="rolloverOn('side-build');"><IMG alt="Build" border="0" height="12" hspace="0" name="side-build" onLoad="rolloverLoad('side-build','../graphics/build-label-2.jpg','../graphics/build-label-3.jpg');" src="../graphics/build-label-3.jpg" vspace="0" width="120"></A><BR>

  <IMG border="0" height="6" hspace="0" src="../resources/separator.gif" vspace="0" width="120"><BR>

  <IMG alt="API Docs" border="0" height="12" hspace="0" src="../graphics/api-label-1.jpg" vspace="0" width="120"><BR>

  <A href="../samples.html" onMouseOut="rolloverOff('side-samples');" onMouseOver="rolloverOn('side-samples');"><IMG alt="Samples" border="0" height="12" hspace="0" name="side-samples" onLoad="rolloverLoad('side-samples','../graphics/samples-label-2.jpg','../graphics/samples-label-3.jpg');" src="../graphics/samples-label-3.jpg" vspace="0" width="120"></A><BR>

  <A href="../schema.html" onMouseOut="rolloverOff('side-schema');" onMouseOver="rolloverOn('side-schema');"><IMG alt="Schema" border="0" height="12" hspace="0" name="side-schema" onLoad="rolloverLoad('side-schema','../graphics/schema-label-2.jpg','../graphics/schema-label-3.jpg');" src="../graphics/schema-label-3.jpg" vspace="0" width="120"></A><BR>
  <IMG border="0" height="6" hspace="0" src="../resources/separator.gif" vspace="0" width="120"><BR>

  <A href="../faqs.html" onMouseOut="rolloverOff('side-faqs');" onMouseOver="rolloverOn('side-faqs');"><IMG alt="FAQs" border="0" height="12" hspace="0" name="side-faqs" onLoad="rolloverLoad('side-faqs','../graphics/faqs-label-2.jpg','../graphics/faqs-label-3.jpg');" src="../graphics/faqs-label-3.jpg" vspace="0" width="120"></A><BR>

  <A href="../program.html" onMouseOut="rolloverOff('side-program');" onMouseOver="rolloverOn('side-program');"><IMG alt="Programming" border="0" height="12" hspace="0" name="side-program" onLoad="rolloverLoad('side-program','../graphics/program-label-2.jpg','../graphics/program-label-3.jpg');" src="../graphics/program-label-3.jpg" vspace="0" width="120"></A><BR>
  <A href="../migrate.html" onMouseOut="rolloverOff('side-migrate');" onMouseOver="rolloverOn('side-migrate');"><IMG alt="Migration" border="0" height="12" hspace="0" name="side-migrate" onLoad="rolloverLoad('side-migrate','../graphics/migrate-label-2.jpg','../graphics/migrate-label-3.jpg');" src="../graphics/migrate-label-3.jpg" vspace="0" width="120"></A><BR>

  <IMG border="0" height="6" hspace="0" src="../resources/separator.gif" vspace="0" width="120"><BR>

  <A href="../releases.html" onMouseOut="rolloverOff('side-releases');" onMouseOver="rolloverOn('side-releases');"><IMG alt="Releases" border="0" height="12" hspace="0" name="side-releases" onLoad="rolloverLoad('side-releases','../graphics/releases-label-2.jpg','../graphics/releases-label-3.jpg');" src="../graphics/releases-label-3.jpg" vspace="0" width="120"></A><BR>
  <A href="../bug-report.html" onMouseOut="rolloverOff('side-bug-report');" onMouseOver="rolloverOn('side-bug-report');"><IMG alt="Bug-Reporting" border="0" height="12" hspace="0" name="side-bug-report" onLoad="rolloverLoad('side-bug-report','../graphics/bug-report-label-2.jpg','../graphics/bug-report-label-3.jpg');" src="../graphics/bug-report-label-3.jpg" vspace="0" width="120"></A><BR>
  <A href="../feedback.html" onMouseOut="rolloverOff('side-feedback');" onMouseOver="rolloverOn('side-feedback');"><IMG alt="Feedback" border="0" height="12" hspace="0" name="side-feedback" onLoad="rolloverLoad('side-feedback','../graphics/feedback-label-2.jpg','../graphics/feedback-label-3.jpg');" src="../graphics/feedback-label-3.jpg" vspace="0" width="120"></A><BR>

  <IMG border="0" height="6" hspace="0" src="../resources/separator.gif" vspace="0" width="120"><BR>
  <A href="../y2k.html" onMouseOut="rolloverOff('side-y2k');" onMouseOver="rolloverOn('side-y2k');"><IMG alt="Y2K Compliance" border="0" height="12" hspace="0" name="side-y2k" onLoad="rolloverLoad('side-y2k','../graphics/y2k-label-2.jpg','../graphics/y2k-label-3.jpg');" src="../graphics/y2k-label-3.jpg" vspace="0" width="120"></A><BR>
  
  <A href="../pdf.html" onMouseOut="rolloverOff('side-pdf');" onMouseOver="rolloverOn('side-pdf');"><IMG alt="PDF Document" border="0" height="12" hspace="0" name="side-pdf" onLoad="rolloverLoad('side-pdf','../graphics/pdf-label-2.jpg','../graphics/pdf-label-3.jpg');" src="../graphics/pdf-label-3.jpg" vspace="0" width="120"></A><BR>

  <IMG border="0" height="6" hspace="0" src="../resources/separator.gif" vspace="0" width="120"><BR>

  <A href="http://xml.apache.org/websrc/cvsweb.cgi/xml-xerces/c/" onMouseOut="rolloverOff('side-ext-96');" onMouseOver="rolloverOn('side-ext-96');"><IMG alt="CVS Repository" border="0" height="12" hspace="0" name="side-ext-96" onLoad="rolloverLoad('side-ext-96','../graphics/ext-96-label-2.jpg','../graphics/ext-96-label-3.jpg');" src="../graphics/ext-96-label-3.jpg" vspace="0" width="120"></A><BR>
  <A href="http://marc.theaimsgroup.com/?l=xerces-c-dev" onMouseOut="rolloverOff('side-ext-98');" onMouseOver="rolloverOn('side-ext-98');"><IMG alt="Mail Archive" border="0" height="12" hspace="0" name="side-ext-98" onLoad="rolloverLoad('side-ext-98','../graphics/ext-98-label-2.jpg','../graphics/ext-98-label-3.jpg');" src="../graphics/ext-98-label-3.jpg" vspace="0" width="120"></A><BR>

<IMG border="0" height="14" hspace="0" src="../resources/close.gif" vspace="0" width="120"><BR></TD><TD align="left" valign="top" width="500"><TABLE border="0" cellpadding="3" cellspacing="0"><TR><TD>
    <TABLE border="0" cellpadding="0" cellspacing="0" width="494"><TR><TD bgcolor="#FFFFFF" colspan="2" width="494"><TABLE border="0" cellpadding="0" cellspacing="0" width="494"><TR><TD bgcolor="#039acc" height="1" width="1"><IMG border="0" height="1" hspace="0" src="../resources/void.gif" vspace="0" width="1"></TD><TD bgcolor="#039acc" height="1" width="492"><IMG border="0" height="1" hspace="0" src="../resources/void.gif" vspace="0" width="492"></TD><TD bgcolor="#0086b2" height="1" width="1"><IMG border="0" height="1" hspace="0" src="../resources/void.gif" vspace="0" width="1"></TD></TR><TR><TD bgcolor="#039acc" width="1"><IMG border="0" height="1" hspace="0" src="../resources/void.gif" vspace="0" width="1"></TD><TD bgcolor="#0086b2" width="492"><FONT color="#ffffff" face="arial,helvetica,sanserif" size="+1"><IMG border="0" height="2" hspace="0" src="../resources/void.gif" vspace="0" width="2"><B>API Docs for SAX and DOM</B></FONT></TD><TD bgcolor="#017299" width="1"><IMG border="0" height="1" hspace="0" src="../resources/void.gif" vspace="0" width="1"></TD></TR><TR><TD bgcolor="#0086b2" height="1" width="1"><IMG border="0" height="1" hspace="0" src="../resources/void.gif" vspace="0" width="1"></TD><TD bgcolor="#017299" height="1" width="492"><IMG border="0" height="1" hspace="0" src="../resources/void.gif" vspace="0" width="492"></TD><TD bgcolor="#017299" height="1" width="1"><IMG border="0" height="1" hspace="0" src="../resources/void.gif" vspace="0" width="1"></TD></TR></TABLE></TD></TR><TR><TD width="10">&nbsp;</TD><TD width="484"><FONT color="#000000" face="arial,helvetica,sanserif">

	    <P>
<!-- Generated by Doxygen 1.2.4 on Thu Mar 7 17:53:03 2002 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>XMLString  Class Reference</h1>Class for representing native character strings and handling common string operations. 
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="XMLString_hpp-source.html">XMLString.hpp</a>&gt;</code>
<p>
<a href="class_XMLString-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Static Public Methods</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion functions</div></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d0">binToText</a> (const unsigned int toFormat,char *const toFill,const unsigned int maxChars,const unsigned int radix)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Converts binary data to a text string based a given radix.</em> <a href="#d0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d1">binToText</a> (const unsigned int toFormat,XMLCh *const toFill,const unsigned int maxChars,const unsigned int radix)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Converts binary data to a text string based a given radix.</em> <a href="#d1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d2">binToText</a> (const unsigned long toFormat,char *const toFill,const unsigned int maxChars,const unsigned int radix)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Converts binary data to a text string based a given radix.</em> <a href="#d2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d3">binToText</a> (const unsigned long toFormat,XMLCh *const toFill,const unsigned int maxChars,const unsigned int radix)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Converts binary data to a text string based a given radix.</em> <a href="#d3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d4">binToText</a> (const long toFormat,char *const toFill,const unsigned int maxChars,const unsigned int radix)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Converts binary data to a text string based a given radix.</em> <a href="#d4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d5">binToText</a> (const long toFormat,XMLCh *const toFill,const unsigned int maxChars,const unsigned int radix)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Converts binary data to a text string based a given radix.</em> <a href="#d5">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d6">binToText</a> (const int toFormat,char *const toFill,const unsigned int maxChars,const unsigned int radix)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Converts binary data to a text string based a given radix.</em> <a href="#d6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d7">binToText</a> (const int toFormat,XMLCh *const toFill,const unsigned int maxChars,const unsigned int radix)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Converts binary data to a text string based a given radix.</em> <a href="#d7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d8">textToBin</a> (const XMLCh *const toConvert,unsigned int &amp;toFill)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Converts a string of decimal chars to a binary value.</em> <a href="#d8">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d9">parseInt</a> (const XMLCh *const toConvert)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Converts a string of decimal chars to a binary value.</em> <a href="#d9">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">String concatenation functions</div></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d10">catString</a> (char *const target,const char *const src)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Concatenates two strings.</em> <a href="#d10">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d11">catString</a> (XMLCh *const target,const XMLCh *const src)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Concatenates two strings.</em> <a href="#d11">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">String comparison functions</div></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d12">compareIString</a> (const char *const str1,const char *const str2)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Lexicographically compares lowercase versions of <code>str1</code> and <code>str2</code> and returns a value indicating their relationship.</em> <a href="#d12">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d13">compareIString</a> (const XMLCh *const str1,const XMLCh *const str2)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Lexicographically compares lowercase versions of <code>str1</code> and <code>str2</code> and returns a value indicating their relationship.</em> <a href="#d13">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d14">compareNString</a> (const char *const str1,const char *const str2,const unsigned int count)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Lexicographically compares, at most, the first count characters in <code>str1</code> and <code>str2</code> and returns a value indicating the relationship between the substrings.</em> <a href="#d14">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d15">compareNString</a> (const XMLCh *const str1,const XMLCh *const str2,const unsigned int count)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Lexicographically compares, at most, the first count characters in <code>str1</code> and <code>str2</code> and returns a value indicating the relationship between the substrings.</em> <a href="#d15">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d16">compareNIString</a> (const char *const str1,const char *const str2,const unsigned int count)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Lexicographically compares, at most, the first count characters in <code>str1</code> and <code>str2</code> without regard to case and returns a value indicating the relationship between the substrings.</em> <a href="#d16">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d17">compareNIString</a> (const XMLCh *const str1,const XMLCh *const str2,const unsigned int count)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Lexicographically compares, at most, the first count characters in <code>str1</code> and <code>str2</code> without regard to case and returns a value indicating the relationship between the substrings.</em> <a href="#d17">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d18">compareString</a> (const char *const str1,const char *const str2)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Lexicographically compares <code>str1</code> and <code>str2</code> and returns a value indicating their relationship.</em> <a href="#d18">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d19">compareString</a> (const XMLCh *const str1,const XMLCh *const str2)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Lexicographically compares <code>str1</code> and <code>str2</code> and returns a value indicating their relationship.</em> <a href="#d19">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d20">regionMatches</a> (const XMLCh *const str1,const int offset1,const XMLCh *const str2,const int offset2,const unsigned int charCount)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Lexicographically compares <code>str1</code> and <code>str2</code> regions and returns true if they are equal, otherwise false.</em> <a href="#d20">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d21">regionIMatches</a> (const XMLCh *const str1,const int offset1,const XMLCh *const str2,const int offset2,const unsigned int charCount)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Lexicographically compares <code>str1</code> and <code>str2</code> regions without regard to case and returns true if they are equal, otherwise false.</em> <a href="#d21">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">String copy functions</div></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d22">copyString</a> (char *const target,const char *const src)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Copies <code>src</code>, including the terminating null character, to the location specified by <code>target</code>.</em> <a href="#d22">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d23">copyString</a> (XMLCh *const target,const XMLCh *const src)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Copies <code>src</code>, including the terminating null character, to the location specified by <code>target</code>.</em> <a href="#d23">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d24">copyNString</a> (XMLCh *const target,const XMLCh *const src,const unsigned int maxChars)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Copies <code>src</code>, upto a fixed number of characters, to the location specified by <code>target</code>.</em> <a href="#d24">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Hash functions</div></td></tr>
<tr><td nowrap align=right valign=top>unsigned int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d25">hash</a> (const char *const toHash,const unsigned int hashModulus)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Hashes a string given a modulus.</em> <a href="#d25">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d26">hash</a> (const XMLCh *const toHash,const unsigned int hashModulus)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Hashes a string given a modulus.</em> <a href="#d26">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d27">hashN</a> (const XMLCh *const toHash,const unsigned int numChars,const unsigned int hashModulus)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Hashes a string given a modulus taking a maximum number of characters as the limit.</em> <a href="#d27">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Search functions</div></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d28">indexOf</a> (const char *const toSearch,const char ch)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Provides the index of the first occurance of a character within a string.</em> <a href="#d28">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d29">indexOf</a> (const XMLCh *const toSearch,const XMLCh ch)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Provides the index of the first occurance of a character within a string.</em> <a href="#d29">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d30">indexOf</a> (const char *const toSearch,const char chToFind,const unsigned int fromIndex)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Provides the index of the first occurance of a character within a string starting from a given index.</em> <a href="#d30">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d31">indexOf</a> (const XMLCh *const toSearch,const XMLCh chToFind,const unsigned int fromIndex)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Provides the index of the first occurance of a character within a string starting from a given index.</em> <a href="#d31">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d32">lastIndexOf</a> (const char *const toSearch,const char ch)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Provides the index of the last occurance of a character within a string.</em> <a href="#d32">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d33">lastIndexOf</a> (const XMLCh *const toSearch,const XMLCh ch)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Provides the index of the last occurance of a character within a string.</em> <a href="#d33">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d34">lastIndexOf</a> (const char *const toSearch,const char chToFind,const unsigned int fromIndex)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Provides the index of the last occurance of a character within a string starting backward from a given index.</em> <a href="#d34">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d35">lastIndexOf</a> (const XMLCh *const toSearch,const XMLCh ch,const unsigned int fromIndex)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Provides the index of the last occurance of a character within a string starting backward from a given index.</em> <a href="#d35">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Fixed size string movement</div></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d36">moveChars</a> (XMLCh *const targetStr,const XMLCh *const srcStr,const unsigned int count)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Moves X number of chars.</em> <a href="#d36">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Substring function</div></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d37">subString</a> (char *const targetStr,const char *const srcStr,const int startIndex,const int endIndex)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a substring of a givend string.</em> <a href="#d37">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d38">subString</a> (XMLCh *const targetStr,const XMLCh *const srcStr,const int startIndex,const int endIndex)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a substring of a givend string.</em> <a href="#d38">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Replication function</div></td></tr>
<tr><td nowrap align=right valign=top>char*&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d39">replicate</a> (const char *const toRep)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Replicates a string.</em> <a href="#d39">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>XMLCh*&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d40">replicate</a> (const XMLCh *const toRep)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Replicates a string.</em> <a href="#d40">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">String query function</div></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d41">startsWith</a> (const char *const toTest,const char *const prefix)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Tells if the sub-string appears within a string at the beginning.</em> <a href="#d41">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d42">startsWith</a> (const XMLCh *const toTest,const XMLCh *const prefix)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Tells if the sub-string appears within a string at the beginning.</em> <a href="#d42">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d43">startsWithI</a> (const char *const toTest,const char *const prefix)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Tells if the sub-string appears within a string at the beginning without regard to case.</em> <a href="#d43">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d44">startsWithI</a> (const XMLCh *const toTest,const XMLCh *const prefix)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Tells if the sub-string appears within a string at the beginning without regard to case.</em> <a href="#d44">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d45">endsWith</a> (const XMLCh *const toTest,const XMLCh *const suffix)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Tells if the sub-string appears within a string at the end.</em> <a href="#d45">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>const XMLCh*&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d46">findAny</a> (const XMLCh *const toSearch,const XMLCh *const searchList)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Tells if a string has any occurance of another string within itself.</em> <a href="#d46">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>XMLCh*&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d47">findAny</a> (XMLCh *const toSearch,const XMLCh *const searchList)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Tells if a string has any occurance of another string within itself.</em> <a href="#d47">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d48">patternMatch</a> (XMLCh *const toSearch,const XMLCh *const pattern)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Tells if a string has pattern within itself.</em> <a href="#d48">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d49">stringLen</a> (const char *const src)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the length of the string.</em> <a href="#d49">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d50">stringLen</a> (const XMLCh *const src)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the length of the string.</em> <a href="#d50">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d51">isValidNCName</a> (const XMLCh *const name)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks whether an name is a valid NCName.</em> <a href="#d51">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d52">isValidName</a> (const XMLCh *const name)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks whether an name is a valid Name.</em> <a href="#d52">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d53">isValidEncName</a> (const XMLCh *const name)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks whether an name is a valid EncName.</em> <a href="#d53">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d54">isValidQName</a> (const XMLCh *const name)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks whether an name is a valid <a class="el" href="class_QName.html">QName</a>.</em> <a href="#d54">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d55">isAlpha</a> (XMLCh const theChar)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks whether a character is within [a-zA-Z].</em> <a href="#d55">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d56">isDigit</a> (XMLCh const theChar)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks whether a character is within [0-9].</em> <a href="#d56">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d57">isAlphaNum</a> (XMLCh const theChar)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks whether a character is within [0-9a-zA-Z].</em> <a href="#d57">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d58">isHex</a> (XMLCh const theChar)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks whether a character is within [0-9a-fA-F].</em> <a href="#d58">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d59">isAllWhiteSpace</a> (const XMLCh *const toCheck)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Checks whether a string contains only whitespace.</em> <a href="#d59">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion functions</div></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d60">cut</a> (XMLCh *const toCutFrom,const unsigned int count)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Cut leading chars from a string.</em> <a href="#d60">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>char*&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d61">transcode</a> (const XMLCh *const toTranscode)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Transcodes a string to native code-page.</em> <a href="#d61">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d62">transcode</a> (const XMLCh *const toTranscode,char *const toFill,const unsigned int maxChars)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Transcodes a string to native code-page.</em> <a href="#d62">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>XMLCh*&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d63">transcode</a> (const char *const toTranscode)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Transcodes a string to native code-page.</em> <a href="#d63">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d64">transcode</a> (const char *const toTranscode,XMLCh *const toFill,const unsigned int maxChars)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Transcodes a string to native code-page.</em> <a href="#d64">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d65">trim</a> (char *const toTrim)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Trims off extra space characters from the start and end of the string, moving the non-space string content back to the start.</em> <a href="#d65">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d66">trim</a> (XMLCh *const toTrim)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Trims off extra space characters from the start and end of the string, moving the non-space string content back to the start.</em> <a href="#d66">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>RefVectorOf&lt;XMLCh&gt;*&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d67">tokenizeString</a> (const XMLCh *const tokenizeSrc)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Break a string into tokens with space as delimiter, and stored in a string vector.</em> <a href="#d67">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d68">isInList</a> (const XMLCh *const toFind,const XMLCh *const enumList)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Find is the string appears in the enum list.</em> <a href="#d68">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Formatting functions</div></td></tr>
<tr><td nowrap align=right valign=top>XMLCh*&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d69">makeUName</a> (const XMLCh *const pszURI,const XMLCh *const pszName)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Creates a UName from a URI and base name.</em> <a href="#d69">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned int&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d70">replaceTokens</a> (XMLCh *const errText,const unsigned int maxChars,const XMLCh *const text1,const XMLCh *const text2,const XMLCh *const text3,const XMLCh *const text4)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Internal function to perform token replacement for strings.</em> <a href="#d70">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d71">upperCase</a> (XMLCh *const toUpperCase)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Converts a string to uppercase.</em> <a href="#d71">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d72">lowerCase</a> (XMLCh *const toLowerCase)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Converts a string to lowercase.</em> <a href="#d72">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d73">isWSReplaced</a> (const XMLCh *const toCheck)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Check if string is WhiteSpace:replace.</em> <a href="#d73">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d74">isWSCollapsed</a> (const XMLCh *const toCheck)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Check if string is WhiteSpace:collapse.</em> <a href="#d74">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d75">replaceWS</a> (XMLCh *const toConvert)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Replace whitespace.</em> <a href="#d75">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="class_XMLString.html#d76">collapseWS</a> (XMLCh *const toConvert)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Collapse whitespace.</em> <a href="#d76">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Friends</h2></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="#l0">XMLPlatformUtils</a></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class for representing native character strings and handling common string operations.
<p>
This class is Unicode compliant. This class is designed primarily for internal use, but due to popular demand, it is being made publicly available. Users of this class must understand that this is not an officially supported class. All public methods of this class are <em>static functions</em>. 
<p>
<hr><h2>Member Function Documentation</h2>
<a name="d7" doxytag="XMLString::binToText"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::binToText (
          </b></td>
          <td valign="bottom"><b>
const int <em>toFormat</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
XMLCh *const <em>toFill</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>maxChars</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>radix</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Converts binary data to a text string based a given radix.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toFormat</em>
&nbsp;</td><td>
 The beginning of the input string to convert </td></tr>
<tr><td valign=top><em>toFill</em>
&nbsp;</td><td>
 The buffer that will hold the output on return. The size of this buffer should at least be 'maxChars + 1'. </td></tr>
<tr><td valign=top><em>maxChars</em>
&nbsp;</td><td>
 The maximum number of output characters that can be accepted. If the result will not fit, it is an error. </td></tr>
<tr><td valign=top><em>radix</em>
&nbsp;</td><td>
 The radix of the input data, based on which the conversion will be done </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d6" doxytag="XMLString::binToText"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::binToText (
          </b></td>
          <td valign="bottom"><b>
const int <em>toFormat</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
char *const <em>toFill</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>maxChars</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>radix</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Converts binary data to a text string based a given radix.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toFormat</em>
&nbsp;</td><td>
 The beginning of the input string to convert </td></tr>
<tr><td valign=top><em>toFill</em>
&nbsp;</td><td>
 The buffer that will hold the output on return. The size of this buffer should at least be 'maxChars + 1'. </td></tr>
<tr><td valign=top><em>maxChars</em>
&nbsp;</td><td>
 The maximum number of output characters that can be accepted. If the result will not fit, it is an error. </td></tr>
<tr><td valign=top><em>radix</em>
&nbsp;</td><td>
 The radix of the input data, based on which the conversion will be done </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d5" doxytag="XMLString::binToText"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::binToText (
          </b></td>
          <td valign="bottom"><b>
const long <em>toFormat</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
XMLCh *const <em>toFill</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>maxChars</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>radix</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Converts binary data to a text string based a given radix.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toFormat</em>
&nbsp;</td><td>
 The beginning of the input string to convert </td></tr>
<tr><td valign=top><em>toFill</em>
&nbsp;</td><td>
 The buffer that will hold the output on return. The size of this buffer should at least be 'maxChars + 1'. </td></tr>
<tr><td valign=top><em>maxChars</em>
&nbsp;</td><td>
 The maximum number of output characters that can be accepted. If the result will not fit, it is an error. </td></tr>
<tr><td valign=top><em>radix</em>
&nbsp;</td><td>
 The radix of the input data, based on which the conversion will be done </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d4" doxytag="XMLString::binToText"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::binToText (
          </b></td>
          <td valign="bottom"><b>
const long <em>toFormat</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
char *const <em>toFill</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>maxChars</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>radix</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Converts binary data to a text string based a given radix.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toFormat</em>
&nbsp;</td><td>
 The beginning of the input string to convert </td></tr>
<tr><td valign=top><em>toFill</em>
&nbsp;</td><td>
 The buffer that will hold the output on return. The size of this buffer should at least be 'maxChars + 1'. </td></tr>
<tr><td valign=top><em>maxChars</em>
&nbsp;</td><td>
 The maximum number of output characters that can be accepted. If the result will not fit, it is an error. </td></tr>
<tr><td valign=top><em>radix</em>
&nbsp;</td><td>
 The radix of the input data, based on which the conversion will be done </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d3" doxytag="XMLString::binToText"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::binToText (
          </b></td>
          <td valign="bottom"><b>
const unsigned long <em>toFormat</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
XMLCh *const <em>toFill</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>maxChars</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>radix</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Converts binary data to a text string based a given radix.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toFormat</em>
&nbsp;</td><td>
 The beginning of the input string to convert </td></tr>
<tr><td valign=top><em>toFill</em>
&nbsp;</td><td>
 The buffer that will hold the output on return. The size of this buffer should at least be 'maxChars + 1'. </td></tr>
<tr><td valign=top><em>maxChars</em>
&nbsp;</td><td>
 The maximum number of output characters that can be accepted. If the result will not fit, it is an error. </td></tr>
<tr><td valign=top><em>radix</em>
&nbsp;</td><td>
 The radix of the input data, based on which the conversion will be done </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d2" doxytag="XMLString::binToText"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::binToText (
          </b></td>
          <td valign="bottom"><b>
const unsigned long <em>toFormat</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
char *const <em>toFill</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>maxChars</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>radix</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Converts binary data to a text string based a given radix.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toFormat</em>
&nbsp;</td><td>
 The beginning of the input string to convert </td></tr>
<tr><td valign=top><em>toFill</em>
&nbsp;</td><td>
 The buffer that will hold the output on return. The size of this buffer should at least be 'maxChars + 1'. </td></tr>
<tr><td valign=top><em>maxChars</em>
&nbsp;</td><td>
 The maximum number of output characters that can be accepted. If the result will not fit, it is an error. </td></tr>
<tr><td valign=top><em>radix</em>
&nbsp;</td><td>
 The radix of the input data, based on which the conversion will be done </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d1" doxytag="XMLString::binToText"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::binToText (
          </b></td>
          <td valign="bottom"><b>
const unsigned int <em>toFormat</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
XMLCh *const <em>toFill</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>maxChars</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>radix</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Converts binary data to a text string based a given radix.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toFormat</em>
&nbsp;</td><td>
 The beginning of the input string to convert </td></tr>
<tr><td valign=top><em>toFill</em>
&nbsp;</td><td>
 The buffer that will hold the output on return. The size of this buffer should at least be 'maxChars + 1'. </td></tr>
<tr><td valign=top><em>maxChars</em>
&nbsp;</td><td>
 The maximum number of output characters that can be accepted. If the result will not fit, it is an error. </td></tr>
<tr><td valign=top><em>radix</em>
&nbsp;</td><td>
 The radix of the input data, based on which the conversion will be done </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d0" doxytag="XMLString::binToText"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::binToText (
          </b></td>
          <td valign="bottom"><b>
const unsigned int <em>toFormat</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
char *const <em>toFill</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>maxChars</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>radix</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Converts binary data to a text string based a given radix.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toFormat</em>
&nbsp;</td><td>
 The beginning of the input string to convert </td></tr>
<tr><td valign=top><em>toFill</em>
&nbsp;</td><td>
 The buffer that will hold the output on return. The size of this buffer should at least be 'maxChars + 1'. </td></tr>
<tr><td valign=top><em>maxChars</em>
&nbsp;</td><td>
 The maximum number of output characters that can be accepted. If the result will not fit, it is an error. </td></tr>
<tr><td valign=top><em>radix</em>
&nbsp;</td><td>
 The radix of the input data, based on which the conversion will be done </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d11" doxytag="XMLString::catString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::catString (
          </b></td>
          <td valign="bottom"><b>
XMLCh *const <em>target</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>src</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Concatenates two strings.
<p>
<code>catString</code> appends <code>src</code> to <code>target</code> and terminates the resulting string with a null character. The initial character of <code>src</code> overwrites the terminating character of <code>target</code>. No overflow checking is performed when strings are copied or appended. The behavior of <code>catString</code> is undefined if source and destination strings overlap.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>target</em>
&nbsp;</td><td>
 Null-terminated destination string </td></tr>
<tr><td valign=top><em>src</em>
&nbsp;</td><td>
 Null-terminated source string </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d10" doxytag="XMLString::catString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::catString (
          </b></td>
          <td valign="bottom"><b>
char *const <em>target</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const char *const <em>src</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Concatenates two strings.
<p>
<code>catString</code> appends <code>src</code> to <code>target</code> and terminates the resulting string with a null character. The initial character of <code>src</code> overwrites the terminating character of <code>target </code>.
<p>
No overflow checking is performed when strings are copied or appended. The behavior of <code>catString</code> is undefined if source and destination strings overlap.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>target</em>
&nbsp;</td><td>
 Null-terminated destination string </td></tr>
<tr><td valign=top><em>src</em>
&nbsp;</td><td>
 Null-terminated source string </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d76" doxytag="XMLString::collapseWS"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::collapseWS (
          </b></td>
          <td valign="bottom"><b>
XMLCh *const <em>toConvert</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Collapse whitespace.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toConvert</em>
&nbsp;</td><td>
 The string which needs to be whitespace collapsed. On return , this buffer also holds the converted string </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d13" doxytag="XMLString::compareIString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::compareIString (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>str1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>str2</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lexicographically compares lowercase versions of <code>str1</code> and <code>str2</code> and returns a value indicating their relationship.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>str1</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
<tr><td valign=top><em>str2</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 The return value indicates the relation of <code>str1</code> to <code>str2</code> as follows Less than 0 means <code>str1</code> is less than <code>str2</code> Equal to 0 means <code>str1</code> is identical to <code>str2</code> Greater than 0 means <code>str1</code> is more than <code>str2</code> </dl>    </td>
  </tr>
</table>
<a name="d12" doxytag="XMLString::compareIString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::compareIString (
          </b></td>
          <td valign="bottom"><b>
const char *const <em>str1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const char *const <em>str2</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lexicographically compares lowercase versions of <code>str1</code> and <code>str2</code> and returns a value indicating their relationship.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>str1</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
<tr><td valign=top><em>str2</em>
&nbsp;</td><td>
 Null-terminated string to compare
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 The return value indicates the relation of <code>str1</code> to <code>str2</code> as follows Less than 0 means <code>str1</code> is less than <code>str2</code> Equal to 0 means <code>str1</code> is identical to <code>str2</code> Greater than 0 means <code>str1</code> is more than <code>str2</code> </dl>    </td>
  </tr>
</table>
<a name="d17" doxytag="XMLString::compareNIString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::compareNIString (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>str1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>str2</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>count</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lexicographically compares, at most, the first count characters in <code>str1</code> and <code>str2</code> without regard to case and returns a value indicating the relationship between the substrings.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>str1</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
<tr><td valign=top><em>str2</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
<tr><td valign=top><em>count</em>
&nbsp;</td><td>
 The number of characters to compare
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 The return value indicates the relation of <code>str1</code> to <code>str2</code> as follows Less than 0 means <code>str1</code> is less than <code>str2</code> Equal to 0 means <code>str1</code> is identical to <code>str2</code> Greater than 0 means <code>str1</code> is more than <code>str2</code> </dl>    </td>
  </tr>
</table>
<a name="d16" doxytag="XMLString::compareNIString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::compareNIString (
          </b></td>
          <td valign="bottom"><b>
const char *const <em>str1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const char *const <em>str2</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>count</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lexicographically compares, at most, the first count characters in <code>str1</code> and <code>str2</code> without regard to case and returns a value indicating the relationship between the substrings.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>str1</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
<tr><td valign=top><em>str2</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
<tr><td valign=top><em>count</em>
&nbsp;</td><td>
 The number of characters to compare </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 The return value indicates the relation of <code>str1</code> to <code>str2</code> as follows Less than 0 means <code>str1</code> is less than <code>str2</code> Equal to 0 means <code>str1</code> is identical to <code>str2</code> Greater than 0 means <code>str1</code> is more than <code>str2</code> </dl>    </td>
  </tr>
</table>
<a name="d15" doxytag="XMLString::compareNString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::compareNString (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>str1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>str2</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>count</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lexicographically compares, at most, the first count characters in <code>str1</code> and <code>str2</code> and returns a value indicating the relationship between the substrings.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>str1</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
<tr><td valign=top><em>str2</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
<tr><td valign=top><em>count</em>
&nbsp;</td><td>
 The number of characters to compare
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 The return value indicates the relation of <code>str1</code> to <code>str2</code> as follows Less than 0 means <code>str1</code> is less than <code>str2</code> Equal to 0 means <code>str1</code> is identical to <code>str2</code> Greater than 0 means <code>str1</code> is more than <code>str2</code> </dl>    </td>
  </tr>
</table>
<a name="d14" doxytag="XMLString::compareNString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::compareNString (
          </b></td>
          <td valign="bottom"><b>
const char *const <em>str1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const char *const <em>str2</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>count</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lexicographically compares, at most, the first count characters in <code>str1</code> and <code>str2</code> and returns a value indicating the relationship between the substrings.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>str1</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
<tr><td valign=top><em>str2</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
<tr><td valign=top><em>count</em>
&nbsp;</td><td>
 The number of characters to compare
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 The return value indicates the relation of <code>str1</code> to <code>str2</code> as follows Less than 0 means <code>str1</code> is less than <code>str2</code> Equal to 0 means <code>str1</code> is identical to <code>str2</code> Greater than 0 means <code>str1</code> is more than <code>str2</code> </dl>    </td>
  </tr>
</table>
<a name="d19" doxytag="XMLString::compareString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::compareString (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>str1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>str2</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lexicographically compares <code>str1</code> and <code>str2</code> and returns a value indicating their relationship.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>str1</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
<tr><td valign=top><em>str2</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 The return value indicates the relation of <code>str1</code> to <code>str2</code> as follows Less than 0 means <code>str1</code> is less than <code>str2</code> Equal to 0 means <code>str1</code> is identical to <code>str2</code> Greater than 0 means <code>str1</code> is more than <code>str2</code> </dl>    </td>
  </tr>
</table>
<a name="d18" doxytag="XMLString::compareString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::compareString (
          </b></td>
          <td valign="bottom"><b>
const char *const <em>str1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const char *const <em>str2</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lexicographically compares <code>str1</code> and <code>str2</code> and returns a value indicating their relationship.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>str1</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
<tr><td valign=top><em>str2</em>
&nbsp;</td><td>
 Null-terminated string to compare
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 The return value indicates the relation of <code>str1</code> to <code>str2</code> as follows Less than 0 means <code>str1</code> is less than <code>str2</code> Equal to 0 means <code>str1</code> is identical to <code>str2</code> Greater than 0 means <code>str1</code> is more than <code>str2</code> </dl>    </td>
  </tr>
</table>
<a name="d24" doxytag="XMLString::copyNString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::copyNString (
          </b></td>
          <td valign="bottom"><b>
XMLCh *const <em>target</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>src</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>maxChars</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copies <code>src</code>, upto a fixed number of characters, to the location specified by <code>target</code>.
<p>
No overflow checking is performed when strings are copied or appended. The behavior of <code>copyNString</code> is undefined if the source and destination strings overlap.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>target</em>
&nbsp;</td><td>
 Destination string. The size of the buffer should atleast be 'maxChars + 1'. </td></tr>
<tr><td valign=top><em>src</em>
&nbsp;</td><td>
 Null-terminated source string </td></tr>
<tr><td valign=top><em>maxChars</em>
&nbsp;</td><td>
 The maximum number of characters to copy </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d23" doxytag="XMLString::copyString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::copyString (
          </b></td>
          <td valign="bottom"><b>
XMLCh *const <em>target</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>src</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copies <code>src</code>, including the terminating null character, to the location specified by <code>target</code>.
<p>
No overflow checking is performed when strings are copied or appended. The behavior of <code>copyString</code> is undefined if the source and destination strings overlap.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>target</em>
&nbsp;</td><td>
 Destination string </td></tr>
<tr><td valign=top><em>src</em>
&nbsp;</td><td>
 Null-terminated source string </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d22" doxytag="XMLString::copyString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::copyString (
          </b></td>
          <td valign="bottom"><b>
char *const <em>target</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const char *const <em>src</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copies <code>src</code>, including the terminating null character, to the location specified by <code>target</code>.
<p>
No overflow checking is performed when strings are copied or appended. The behavior of strcpy is undefined if the source and destination strings overlap.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>target</em>
&nbsp;</td><td>
 Destination string </td></tr>
<tr><td valign=top><em>src</em>
&nbsp;</td><td>
 Null-terminated source string </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d60" doxytag="XMLString::cut"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::cut (
          </b></td>
          <td valign="bottom"><b>
XMLCh *const <em>toCutFrom</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>count</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cut leading chars from a string.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toCutFrom</em>
&nbsp;</td><td>
 The string to cut chars from </td></tr>
<tr><td valign=top><em>count</em>
&nbsp;</td><td>
 The count of leading chars to cut </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d45" doxytag="XMLString::endsWith"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::endsWith (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toTest</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>suffix</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Tells if the sub-string appears within a string at the end.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toTest</em>
&nbsp;</td><td>
 The string to test </td></tr>
<tr><td valign=top><em>suffix</em>
&nbsp;</td><td>
 The sub-string that needs to be checked </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns true if the sub-string was found at the end of <code>toTest</code>, else false </dl>    </td>
  </tr>
</table>
<a name="d47" doxytag="XMLString::findAny"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
XMLCh * XMLString::findAny (
          </b></td>
          <td valign="bottom"><b>
XMLCh *const <em>toSearch</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>searchList</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Tells if a string has any occurance of another string within itself.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toSearch</em>
&nbsp;</td><td>
 The string to be searched </td></tr>
<tr><td valign=top><em>searchList</em>
&nbsp;</td><td>
 The sub-string to be searched within the string </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns the pointer to the location where the sub-string was found, else returns 0 </dl>    </td>
  </tr>
</table>
<a name="d46" doxytag="XMLString::findAny"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
const XMLCh * XMLString::findAny (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toSearch</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>searchList</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Tells if a string has any occurance of another string within itself.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toSearch</em>
&nbsp;</td><td>
 The string to be searched </td></tr>
<tr><td valign=top><em>searchList</em>
&nbsp;</td><td>
 The sub-string to be searched within the string </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns the pointer to the location where the sub-string was found, else returns 0 </dl>    </td>
  </tr>
</table>
<a name="d26" doxytag="XMLString::hash"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned int XMLString::hash (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toHash</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>hashModulus</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Hashes a string given a modulus.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toHash</em>
&nbsp;</td><td>
 The string to hash </td></tr>
<tr><td valign=top><em>hashModulus</em>
&nbsp;</td><td>
 The divisor to be used for hashing </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns the hash value </dl>    </td>
  </tr>
</table>
<a name="d25" doxytag="XMLString::hash"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned int XMLString::hash (
          </b></td>
          <td valign="bottom"><b>
const char *const <em>toHash</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>hashModulus</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Hashes a string given a modulus.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toHash</em>
&nbsp;</td><td>
 The string to hash </td></tr>
<tr><td valign=top><em>hashModulus</em>
&nbsp;</td><td>
 The divisor to be used for hashing </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns the hash value </dl>    </td>
  </tr>
</table>
<a name="d27" doxytag="XMLString::hashN"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned int XMLString::hashN (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toHash</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>numChars</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>hashModulus</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Hashes a string given a modulus taking a maximum number of characters as the limit.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toHash</em>
&nbsp;</td><td>
 The string to hash </td></tr>
<tr><td valign=top><em>numChars</em>
&nbsp;</td><td>
 The maximum number of characters to consider for hashing </td></tr>
<tr><td valign=top><em>hashModulus</em>
&nbsp;</td><td>
 The divisor to be used for hashing
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns the hash value </dl>    </td>
  </tr>
</table>
<a name="d31" doxytag="XMLString::indexOf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::indexOf (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toSearch</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh <em>chToFind</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>fromIndex</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Provides the index of the first occurance of a character within a string starting from a given index.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toSearch</em>
&nbsp;</td><td>
 The string to search </td></tr>
<tr><td valign=top><em>chToFind</em>
&nbsp;</td><td>
 The character to search within the string </td></tr>
<tr><td valign=top><em>fromIndex</em>
&nbsp;</td><td>
 The index to start search from </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 If found, returns the index of the character within the string, else returns -1. </dl>    </td>
  </tr>
</table>
<a name="d30" doxytag="XMLString::indexOf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::indexOf (
          </b></td>
          <td valign="bottom"><b>
const char *const <em>toSearch</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const char <em>chToFind</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>fromIndex</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Provides the index of the first occurance of a character within a string starting from a given index.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toSearch</em>
&nbsp;</td><td>
 The string to search </td></tr>
<tr><td valign=top><em>chToFind</em>
&nbsp;</td><td>
 The character to search within the string </td></tr>
<tr><td valign=top><em>fromIndex</em>
&nbsp;</td><td>
 The index to start earch from </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 If found, returns the index of the character within the string, else returns -1. </dl>    </td>
  </tr>
</table>
<a name="d29" doxytag="XMLString::indexOf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::indexOf (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toSearch</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh <em>ch</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Provides the index of the first occurance of a character within a string.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toSearch</em>
&nbsp;</td><td>
 The string to search </td></tr>
<tr><td valign=top><em>ch</em>
&nbsp;</td><td>
 The character to search within the string </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 If found, returns the index of the character within the string, else returns -1. </dl>    </td>
  </tr>
</table>
<a name="d28" doxytag="XMLString::indexOf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::indexOf (
          </b></td>
          <td valign="bottom"><b>
const char *const <em>toSearch</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const char <em>ch</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Provides the index of the first occurance of a character within a string.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toSearch</em>
&nbsp;</td><td>
 The string to search </td></tr>
<tr><td valign=top><em>ch</em>
&nbsp;</td><td>
 The character to search within the string </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 If found, returns the index of the character within the string, else returns -1. </dl>    </td>
  </tr>
</table>
<a name="d59" doxytag="XMLString::isAllWhiteSpace"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::isAllWhiteSpace (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toCheck</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks whether a string contains only whitespace.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toCheck</em>
&nbsp;</td><td>
 the string to check </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns true if it is, otherwise false </dl>    </td>
  </tr>
</table>
<a name="d55" doxytag="XMLString::isAlpha"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::isAlpha (
          </b></td>
          <td valign="bottom"><b>
XMLCh const <em>theChar</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks whether a character is within [a-zA-Z].
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>theChar</em>
&nbsp;</td><td>
 the character to check </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns true if within the range, otherwise false </dl>    </td>
  </tr>
</table>
<a name="d57" doxytag="XMLString::isAlphaNum"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::isAlphaNum (
          </b></td>
          <td valign="bottom"><b>
XMLCh const <em>theChar</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks whether a character is within [0-9a-zA-Z].
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>theChar</em>
&nbsp;</td><td>
 the character to check </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns true if within the range, otherwise false </dl>    </td>
  </tr>
</table>
<a name="d56" doxytag="XMLString::isDigit"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::isDigit (
          </b></td>
          <td valign="bottom"><b>
XMLCh const <em>theChar</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks whether a character is within [0-9].
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>theChar</em>
&nbsp;</td><td>
 the character to check </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns true if within the range, otherwise false </dl>    </td>
  </tr>
</table>
<a name="d58" doxytag="XMLString::isHex"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::isHex (
          </b></td>
          <td valign="bottom"><b>
XMLCh const <em>theChar</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks whether a character is within [0-9a-fA-F].
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>theChar</em>
&nbsp;</td><td>
 the character to check </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns true if within the range, otherwise false </dl>    </td>
  </tr>
</table>
<a name="d68" doxytag="XMLString::isInList"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::isInList (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toFind</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>enumList</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find is the string appears in the enum list.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toFind</em>
&nbsp;</td><td>
 the string to be found </td></tr>
<tr><td valign=top><em>enumList</em>
&nbsp;</td><td>
 the list return true if found </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d53" doxytag="XMLString::isValidEncName"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::isValidEncName (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>name</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks whether an name is a valid EncName.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>name</em>
&nbsp;</td><td>
 The string to check its EncName validity </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns true if name is EncName valid, otherwise false </dl>    </td>
  </tr>
</table>
<a name="d51" doxytag="XMLString::isValidNCName"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::isValidNCName (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>name</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks whether an name is a valid NCName.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>name</em>
&nbsp;</td><td>
 The string to check its NCName validity </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns true if name is NCName valid, otherwise false </dl>    </td>
  </tr>
</table>
<a name="d52" doxytag="XMLString::isValidName"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::isValidName (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>name</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks whether an name is a valid Name.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>name</em>
&nbsp;</td><td>
 The string to check its Name validity </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns true if name is Name valid, otherwise false </dl>    </td>
  </tr>
</table>
<a name="d54" doxytag="XMLString::isValidQName"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::isValidQName (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>name</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks whether an name is a valid <a class="el" href="class_QName.html">QName</a>.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>name</em>
&nbsp;</td><td>
 The string to check its <a class="el" href="class_QName.html">QName</a> validity </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns true if name is <a class="el" href="class_QName.html">QName</a> valid, otherwise false </dl>    </td>
  </tr>
</table>
<a name="d74" doxytag="XMLString::isWSCollapsed"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::isWSCollapsed (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toCheck</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if string is WhiteSpace:collapse.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toCheck</em>
&nbsp;</td><td>
 The string which needs to be checked. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d73" doxytag="XMLString::isWSReplaced"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::isWSReplaced (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toCheck</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if string is WhiteSpace:replace.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toCheck</em>
&nbsp;</td><td>
 The string which needs to be checked. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d35" doxytag="XMLString::lastIndexOf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::lastIndexOf (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toSearch</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh <em>ch</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>fromIndex</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Provides the index of the last occurance of a character within a string starting backward from a given index.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toSearch</em>
&nbsp;</td><td>
 The string to search </td></tr>
<tr><td valign=top><em>ch</em>
&nbsp;</td><td>
 The character to search within the string </td></tr>
<tr><td valign=top><em>fromIndex</em>
&nbsp;</td><td>
 The index to start backward search from </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 If found, returns the index of the character within the string, else returns -1. </dl>    </td>
  </tr>
</table>
<a name="d34" doxytag="XMLString::lastIndexOf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::lastIndexOf (
          </b></td>
          <td valign="bottom"><b>
const char *const <em>toSearch</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const char <em>chToFind</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>fromIndex</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Provides the index of the last occurance of a character within a string starting backward from a given index.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toSearch</em>
&nbsp;</td><td>
 The string to search </td></tr>
<tr><td valign=top><em>chToFind</em>
&nbsp;</td><td>
 The character to search within the string </td></tr>
<tr><td valign=top><em>fromIndex</em>
&nbsp;</td><td>
 The index to start backward search from </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 If found, returns the index of the character within the string, else returns -1. </dl>    </td>
  </tr>
</table>
<a name="d33" doxytag="XMLString::lastIndexOf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::lastIndexOf (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toSearch</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh <em>ch</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Provides the index of the last occurance of a character within a string.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toSearch</em>
&nbsp;</td><td>
 The string to search </td></tr>
<tr><td valign=top><em>ch</em>
&nbsp;</td><td>
 The character to search within the string </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 If found, returns the index of the character within the string, else returns -1. </dl>    </td>
  </tr>
</table>
<a name="d32" doxytag="XMLString::lastIndexOf"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::lastIndexOf (
          </b></td>
          <td valign="bottom"><b>
const char *const <em>toSearch</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const char <em>ch</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Provides the index of the last occurance of a character within a string.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toSearch</em>
&nbsp;</td><td>
 The string to search </td></tr>
<tr><td valign=top><em>ch</em>
&nbsp;</td><td>
 The character to search within the string </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 If found, returns the index of the character within the string, else returns -1. </dl>    </td>
  </tr>
</table>
<a name="d72" doxytag="XMLString::lowerCase"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::lowerCase (
          </b></td>
          <td valign="bottom"><b>
XMLCh *const <em>toLowerCase</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Converts a string to lowercase.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toLowerCase</em>
&nbsp;</td><td>
 The string which needs to be converted to lowercase. On return, this buffer also holds the converted lowercase string </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d69" doxytag="XMLString::makeUName"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
XMLCh * XMLString::makeUName (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>pszURI</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>pszName</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a UName from a URI and base name.
<p>
It is in the form {url}name, and is commonly used internally to represent fully qualified names when namespaces are enabled.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>pszURI</em>
&nbsp;</td><td>
 The URI part of the name </td></tr>
<tr><td valign=top><em>pszName</em>
&nbsp;</td><td>
 The base part of the name </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns the complete formatted UName </dl>    </td>
  </tr>
</table>
<a name="d36" doxytag="XMLString::moveChars"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::moveChars (
          </b></td>
          <td valign="bottom"><b>
XMLCh *const <em>targetStr</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>srcStr</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>count</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Moves X number of chars.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>targetStr</em>
&nbsp;</td><td>
 The string to copy the chars to </td></tr>
<tr><td valign=top><em>srcStr</em>
&nbsp;</td><td>
 The string to copy the chars from </td></tr>
<tr><td valign=top><em>count</em>
&nbsp;</td><td>
 The number of chars to move </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d9" doxytag="XMLString::parseInt"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::parseInt (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toConvert</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Converts a string of decimal chars to a binary value.
<p>
Note that leading and trailng whitespace is legal and will be ignored,
<p>
Only one and either of (+,-) after the leading whitespace, before any other characters are allowed.
<p>
but the remainder must be all decimal digits.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toConvert</em>
&nbsp;</td><td>
 The string of digits to convert </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d48" doxytag="XMLString::patternMatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
int XMLString::patternMatch (
          </b></td>
          <td valign="bottom"><b>
XMLCh *const <em>toSearch</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>pattern</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Tells if a string has pattern within itself.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toSearch</em>
&nbsp;</td><td>
 The string to be searched </td></tr>
<tr><td valign=top><em>pattern</em>
&nbsp;</td><td>
 The pattern to be searched within the string </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns index to the location where the pattern was found, else returns -1 </dl>    </td>
  </tr>
</table>
<a name="d21" doxytag="XMLString::regionIMatches"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::regionIMatches (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>str1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const int <em>offset1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>str2</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const int <em>offset2</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>charCount</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lexicographically compares <code>str1</code> and <code>str2</code> regions without regard to case and returns true if they are equal, otherwise false.
<p>
A substring of <code>str1</code> is compared to a substring of <code>str2</code>. The result is true if these substrings represent identical character sequences. The substring of <code>str1</code> to be compared begins at offset1 and has length charCount. The substring of <code>str2</code> to be compared begins at offset2 and has length charCount. The result is false if and only if at least one of the following is true: offset1 is negative. offset2 is negative. offset1+charCount is greater than the length of str1. offset2+charCount is greater than the length of str2. There is some nonnegative integer k less than charCount such that: str1.charAt(offset1+k) != str2.charAt(offset2+k)<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>str1</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
<tr><td valign=top><em>offset1</em>
&nbsp;</td><td>
 Starting offset of str1 </td></tr>
<tr><td valign=top><em>str2</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
<tr><td valign=top><em>offset2</em>
&nbsp;</td><td>
 Starting offset of str2 </td></tr>
<tr><td valign=top><em>charCount</em>
&nbsp;</td><td>
 The number of characters to compare </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 true if the specified subregion of <code>str1</code> exactly matches the specified subregion of <code>str2&gt;</code>; false otherwise. </dl>    </td>
  </tr>
</table>
<a name="d20" doxytag="XMLString::regionMatches"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::regionMatches (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>str1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const int <em>offset1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>str2</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const int <em>offset2</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>charCount</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lexicographically compares <code>str1</code> and <code>str2</code> regions and returns true if they are equal, otherwise false.
<p>
A substring of <code>str1</code> is compared to a substring of <code>str2</code>. The result is true if these substrings represent identical character sequences. The substring of <code>str1</code> to be compared begins at offset1 and has length charCount. The substring of <code>str2</code> to be compared begins at offset2 and has length charCount. The result is false if and only if at least one of the following is true: offset1 is negative. offset2 is negative. offset1+charCount is greater than the length of str1. offset2+charCount is greater than the length of str2. There is some nonnegative integer k less than charCount such that: str1.charAt(offset1+k) != str2.charAt(offset2+k)<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>str1</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
<tr><td valign=top><em>offset1</em>
&nbsp;</td><td>
 Starting offset of str1 </td></tr>
<tr><td valign=top><em>str2</em>
&nbsp;</td><td>
 Null-terminated string to compare </td></tr>
<tr><td valign=top><em>offset2</em>
&nbsp;</td><td>
 Starting offset of str2 </td></tr>
<tr><td valign=top><em>charCount</em>
&nbsp;</td><td>
 The number of characters to compare </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 true if the specified subregion of <code>str1</code> exactly matches the specified subregion of <code>str2&gt;</code>; false otherwise. </dl>    </td>
  </tr>
</table>
<a name="d70" doxytag="XMLString::replaceTokens"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned int XMLString::replaceTokens (
          </b></td>
          <td valign="bottom"><b>
XMLCh *const <em>errText</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>maxChars</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>text1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>text2</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>text3</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>text4</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Internal function to perform token replacement for strings.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>errText</em>
&nbsp;</td><td>
 The text (NULL terminated) where the replacement is to be done. The size of this buffer should be 'maxChars + 1' to account for the final NULL. </td></tr>
<tr><td valign=top><em>maxChars</em>
&nbsp;</td><td>
 The size of the output buffer, i.e. the maximum number of characters that it will hold. If the result is larger, it will be truncated. </td></tr>
<tr><td valign=top><em>text1</em>
&nbsp;</td><td>
 Replacement text-one </td></tr>
<tr><td valign=top><em>text2</em>
&nbsp;</td><td>
 Replacement text-two </td></tr>
<tr><td valign=top><em>text3</em>
&nbsp;</td><td>
 Replacement text-three </td></tr>
<tr><td valign=top><em>text4</em>
&nbsp;</td><td>
 Replacement text-four </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns the count of characters that are outputted </dl>    </td>
  </tr>
</table>
<a name="d75" doxytag="XMLString::replaceWS"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::replaceWS (
          </b></td>
          <td valign="bottom"><b>
XMLCh *const <em>toConvert</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Replace whitespace.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toConvert</em>
&nbsp;</td><td>
 The string which needs to be whitespace replaced. On return , this buffer also holds the converted string </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d40" doxytag="XMLString::replicate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
XMLCh * XMLString::replicate (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toRep</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Replicates a string.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toRep</em>
&nbsp;</td><td>
 The string to replicate </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns a pointer to the replicated string </dl>    </td>
  </tr>
</table>
<a name="d39" doxytag="XMLString::replicate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
char * XMLString::replicate (
          </b></td>
          <td valign="bottom"><b>
const char *const <em>toRep</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Replicates a string.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toRep</em>
&nbsp;</td><td>
 The string to replicate </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns a pointer to the replicated string </dl>    </td>
  </tr>
</table>
<a name="d42" doxytag="XMLString::startsWith"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::startsWith (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toTest</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>prefix</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Tells if the sub-string appears within a string at the beginning.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toTest</em>
&nbsp;</td><td>
 The string to test </td></tr>
<tr><td valign=top><em>prefix</em>
&nbsp;</td><td>
 The sub-string that needs to be checked </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns true if the sub-string was found at the beginning of <code>toTest</code>, else false </dl>    </td>
  </tr>
</table>
<a name="d41" doxytag="XMLString::startsWith"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::startsWith (
          </b></td>
          <td valign="bottom"><b>
const char *const <em>toTest</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const char *const <em>prefix</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Tells if the sub-string appears within a string at the beginning.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toTest</em>
&nbsp;</td><td>
 The string to test </td></tr>
<tr><td valign=top><em>prefix</em>
&nbsp;</td><td>
 The sub-string that needs to be checked </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns true if the sub-string was found at the beginning of <code>toTest</code>, else false </dl>    </td>
  </tr>
</table>
<a name="d44" doxytag="XMLString::startsWithI"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::startsWithI (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toTest</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>prefix</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Tells if the sub-string appears within a string at the beginning without regard to case.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toTest</em>
&nbsp;</td><td>
 The string to test </td></tr>
<tr><td valign=top><em>prefix</em>
&nbsp;</td><td>
 The sub-string that needs to be checked
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns true if the sub-string was found at the beginning of <code>toTest</code>, else false </dl>    </td>
  </tr>
</table>
<a name="d43" doxytag="XMLString::startsWithI"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::startsWithI (
          </b></td>
          <td valign="bottom"><b>
const char *const <em>toTest</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const char *const <em>prefix</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Tells if the sub-string appears within a string at the beginning without regard to case.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toTest</em>
&nbsp;</td><td>
 The string to test </td></tr>
<tr><td valign=top><em>prefix</em>
&nbsp;</td><td>
 The sub-string that needs to be checked </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns true if the sub-string was found at the beginning of <code>toTest</code>, else false </dl>    </td>
  </tr>
</table>
<a name="d50" doxytag="XMLString::stringLen"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned int XMLString::stringLen (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>src</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the length of the string.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>src</em>
&nbsp;</td><td>
 The string whose length is to be determined </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns the length of the string </dl>    </td>
  </tr>
</table>
<a name="d49" doxytag="XMLString::stringLen"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned int XMLString::stringLen (
          </b></td>
          <td valign="bottom"><b>
const char *const <em>src</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the length of the string.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>src</em>
&nbsp;</td><td>
 The string whose length is to be determined </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns the length of the string </dl>    </td>
  </tr>
</table>
<a name="d38" doxytag="XMLString::subString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::subString (
          </b></td>
          <td valign="bottom"><b>
XMLCh *const <em>targetStr</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const XMLCh *const <em>srcStr</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const int <em>startIndex</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const int <em>endIndex</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a substring of a givend string.
<p>
The substring begins at the specified beginIndex and extends to the character at index endIndex - 1. <dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>targetStr</em>
&nbsp;</td><td>
 The string to copy the chars to </td></tr>
<tr><td valign=top><em>srcStr</em>
&nbsp;</td><td>
 The string to copy the chars from </td></tr>
<tr><td valign=top><em>startIndex</em>
&nbsp;</td><td>
 beginning index, inclusive. </td></tr>
<tr><td valign=top><em>endIndex</em>
&nbsp;</td><td>
 the ending index, exclusive. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d37" doxytag="XMLString::subString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::subString (
          </b></td>
          <td valign="bottom"><b>
char *const <em>targetStr</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const char *const <em>srcStr</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const int <em>startIndex</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const int <em>endIndex</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a substring of a givend string.
<p>
The substring begins at the specified beginIndex and extends to the character at index endIndex - 1. <dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>targetStr</em>
&nbsp;</td><td>
 The string to copy the chars to </td></tr>
<tr><td valign=top><em>srcStr</em>
&nbsp;</td><td>
 The string to copy the chars from </td></tr>
<tr><td valign=top><em>startIndex</em>
&nbsp;</td><td>
 beginning index, inclusive. </td></tr>
<tr><td valign=top><em>endIndex</em>
&nbsp;</td><td>
 the ending index, exclusive. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d8" doxytag="XMLString::textToBin"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::textToBin (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toConvert</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
unsigned int &amp; <em>toFill</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Converts a string of decimal chars to a binary value.
<p>
Note that leading and trailng whitespace is legal and will be ignored but the remainder must be all decimal digits.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toConvert</em>
&nbsp;</td><td>
 The string of digits to convert </td></tr>
<tr><td valign=top><em>toFill</em>
&nbsp;</td><td>
 The unsigned int value to fill with the converted value. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d67" doxytag="XMLString::tokenizeString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
RefVectorOf&lt; XMLCh &gt; * XMLString::tokenizeString (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>tokenizeSrc</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Break a string into tokens with space as delimiter, and stored in a string vector.
<p>
The caller owns the string vector that is returned, and is responsible for deleting it. <dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>tokenizeSrc</em>
&nbsp;</td><td>
 String to be tokenized </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 a vector of all the tokenized string </dl>    </td>
  </tr>
</table>
<a name="d64" doxytag="XMLString::transcode"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::transcode (
          </b></td>
          <td valign="bottom"><b>
const char *const <em>toTranscode</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
XMLCh *const <em>toFill</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>maxChars</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Transcodes a string to native code-page.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toTranscode</em>
&nbsp;</td><td>
 The string tobe transcoded </td></tr>
<tr><td valign=top><em>toFill</em>
&nbsp;</td><td>
 The buffer that is filled with the transcoded value. The size of this buffer should atleast be 'maxChars + 1'. </td></tr>
<tr><td valign=top><em>maxChars</em>
&nbsp;</td><td>
 The maximum number of characters that the output buffer can hold (not including the null, which is why toFill should be at least maxChars+1.) If the resulting output cannot fit into this many characters, it is an error and false is returned. </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns true if successful, false if there was an error </dl>    </td>
  </tr>
</table>
<a name="d63" doxytag="XMLString::transcode"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
XMLCh * XMLString::transcode (
          </b></td>
          <td valign="bottom"><b>
const char *const <em>toTranscode</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Transcodes a string to native code-page.
<p>
NOTE: The returned buffer is dynamically allocated and is the responsibility of the caller to delete it when not longer needed.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toTranscode</em>
&nbsp;</td><td>
 The string to be transcoded </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns the transcoded string </dl>    </td>
  </tr>
</table>
<a name="d62" doxytag="XMLString::transcode"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool XMLString::transcode (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toTranscode</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
char *const <em>toFill</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
const unsigned int <em>maxChars</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Transcodes a string to native code-page.
<p>
Be aware that when transcoding to an external encoding, that each Unicode char can create multiple output bytes. So you cannot assume a one to one correspondence of input chars to output bytes.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toTranscode</em>
&nbsp;</td><td>
 The string tobe transcoded </td></tr>
<tr><td valign=top><em>toFill</em>
&nbsp;</td><td>
 The buffer that is filled with the transcoded value. The size of this buffer should atleast be 'maxChars + 1'. </td></tr>
<tr><td valign=top><em>maxChars</em>
&nbsp;</td><td>
 The maximum number of bytes that the output buffer can hold (not including the null, which is why toFill should be at least maxChars+1.) If the resulting output cannot fit into this many bytes, it is an error and false is returned. </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns true if successful, false if there was an error </dl>    </td>
  </tr>
</table>
<a name="d61" doxytag="XMLString::transcode"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
char * XMLString::transcode (
          </b></td>
          <td valign="bottom"><b>
const XMLCh *const <em>toTranscode</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Transcodes a string to native code-page.
<p>
NOTE: The returned buffer is dynamically allocated and is the responsibility of the caller to delete it when not longer needed.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toTranscode</em>
&nbsp;</td><td>
 The string to be transcoded </td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
 Returns the transcoded string </dl>    </td>
  </tr>
</table>
<a name="d66" doxytag="XMLString::trim"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::trim (
          </b></td>
          <td valign="bottom"><b>
XMLCh *const <em>toTrim</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Trims off extra space characters from the start and end of the string, moving the non-space string content back to the start.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toTrim</em>
&nbsp;</td><td>
 The string to be trimmed. On return this contains the trimmed string </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d65" doxytag="XMLString::trim"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::trim (
          </b></td>
          <td valign="bottom"><b>
char *const <em>toTrim</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Trims off extra space characters from the start and end of the string, moving the non-space string content back to the start.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toTrim</em>
&nbsp;</td><td>
 The string to be trimmed. On return this contains the trimmed string </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="d71" doxytag="XMLString::upperCase"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void XMLString::upperCase (
          </b></td>
          <td valign="bottom"><b>
XMLCh *const <em>toUpperCase</em>&nbsp;)<code> [static]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Converts a string to uppercase.
<p>
<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>toUpperCase</em>
&nbsp;</td><td>
 The string which needs to be converted to uppercase. On return, this buffer also holds the converted uppercase string </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<hr><h2>Friends And Related Function Documentation</h2>
<a name="l0" doxytag="XMLString::XMLPlatformUtils"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
class XMLPlatformUtils<code> [friend]</code>
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="XMLString_hpp-source.html">XMLString.hpp</a></ul>
    </FONT></TD></TR></TABLE><BR>
</TD></TR></TABLE></TD></TR></TABLE><BR><TABLE border="0" cellpadding="0" cellspacing="0" width="620"><TR><TD bgcolor="#0086b2"><IMG height="1" src="images/dot.gif" width="1"></TD></TR><TR><TD align="center"><FONT color="#0086b2" size="-1"><I>
              Copyright &copy; 2000 The Apache Software Foundation.
              All Rights Reserved.
            </I></FONT></TD></TR></TABLE></BODY></HTML>
